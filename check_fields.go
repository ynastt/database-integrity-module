// check all field of docs in collections: btcBlock, btcTx, btcIn, btcOut, btcParentBlock
// btcAddress was checked during checking _key fields
package main

import (
	"flag"
	"fmt"
	"log"
	"math"
	"strconv"
	"strings"
	"os"
	driver "github.com/arangodb/go-driver"
	"github.com/arangodb/go-driver/http"
	"github.com/Toorop/go-bitcoind"
)


type BitcoinTxNode struct {
	Key	string	`json:"_key"`
	Time 	int64	`json:"time"`
}

type BitcoinBlockNode struct {
	BlockHeight	uint64  `json:"blockHeight"` 
	Key		string	`json:"_key"`		//string(blockHeight)
	BlockHash	string	`json:"blockHash"`
}

type BitcoinParentBlockEdge struct {
	Key		string	`json:"_key"`	
	From		string	`json:"_from"`	
	To		string	`json:"_to"`	
}

type BitcoinOutputEdge struct {
	Key		string	`json:"_key"`	// arango _key is generated by arango txId + '_' + outIndex
	From		string	`json:"_from"`	// arango id of transaction 'btcTx/{_key}'
	To		string	`json:"_to"`	// arango id of block 'btcAddress/{_key}'
	OutIndex	int	`json:"outIndex`
	SpentBtc	uint64	`json:"spentBtc"`
	Time 		int64	`json:"time"`
}

type BitcoinNextEdge struct {
	Key		string	`json:"_key"`	// arango _key is generated by arango  txId + '_' + outIndex
	From		string	`json:"_from"`	// arango id of transaction 'btcTx/{_key}'
	To		string	`json:"_to"`	// arango id of block 'btcTx/{_key}'
	Address	string	`json:"address"`
	OutIndex	int 	`json:"outIndex`
	SpentBtc	uint64	`json:"spentBtc"`
}	

//BitcoinInEdge has the same structure as BitcoinOutputEdge but _from :'btcAddress/{_key}', _to: 'btcTx/{_key}'

const (
	SERVER_HOST        = "localhost"
	SERVER_PORT        = 10001
	USER               = "btcuser"
	PASSWD             = "1234"
	USESSL             = false
)

var file *os.File
var db driver.Database

func main() {

	/* connect to bitcoin-core */
	bc, err := bitcoind.New(SERVER_HOST, SERVER_PORT, USER, PASSWD, USESSL)
	if err != nil {
		log.Fatalln(err)
	}
	
	/* connect to arangodb server using http */
	var client driver.Client
	var conn driver.Connection
	
	flag.Parse()

	conn, err = http.NewConnection(http.ConnectionConfig{
		Endpoints: []string{"http://localhost:8529"},
	})
	if err != nil {
		log.Fatalf("Failed to create HTTP connection: %v", err)
	}
	client, err = driver.NewClient(driver.ClientConfig{
		Connection:     conn,
		Authentication: driver.BasicAuthentication("root", ""),
	})
	
	/* open ArangoDB database with "db_name: name */
	fmt.Println("Enter database name: ")
	var db_name string
	fmt.Scanf("%s", &db_name)
	db_exists, err := client.DatabaseExists(nil, db_name)
	
	if db_exists {
		db, err = client.Database(nil, db_name)
		if err != nil {
			log.Fatalf("Failed to open existing database: %v", err)
		} 
		fmt.Println(db.Name() + " exists")
	} else {
		fmt.Println("Sorry, database with this name doesn`t exist")
		fmt.Println("Do you want to create database with this name? [y/n]: ")
		var ans string
		fmt.Scanf("%s", &ans) 
		if ans == "y" {
			db, err = client.CreateDatabase(nil, db_name, nil)
			if err != nil {
				log.Fatalf("Failed to create database: %v", err)
			}
			fmt.Println("the database is successfully created. Rerun the program")
			os.Exit(1)
		}
		if ans == "n" {
			fmt.Println("Rerun the program and enter the correct database name ")
			os.Exit(1)
		}
	}
	
	/* make file for nodes and edges with incorrect field values */
	file, err = os.Create("incorrect_fields.txt")
    	if err != nil{
        	fmt.Println("Unable to create file:", err) 
        	os.Exit(1) 
    	}
    	defer file.Close() 
	
	/* getblockcount */
	/*count, err := bc.GetBlockCount()
	if err != nil {
		log.Fatalf("Failed to get blockCount: %v", err)
	}
	log.Printf("Block count: %d", count) */
			
	/* for saving _key fields of docs for ImportDocuments method */
	arr_block := make([]BitcoinBlockNode, 0, 100)	
	arr_tx := make([]BitcoinTxNode, 0, 1000)	
	arr_in := make([]BitcoinOutputEdge, 0, 1000)	
	arr_out := make([]BitcoinOutputEdge, 0, 1000)	
	arr_next := make([]BitcoinNextEdge, 0, 1000)	
	arr_parent := make([]BitcoinParentBlockEdge, 0, 1000)		
	
	var start, end uint64
    	fmt.Println("Enter the starting block index: ")
    	fmt.Scanf("%d", &start)
    	fmt.Println("Enter the ending block index: ")
    	fmt.Scanf("%d", &end)
    	
    	/* make chans for each of collection */
	/* later we`ll call goroutines for each collection*/
	//blocks := make(chan []BitcoinBlockNode, end-start+1)			
	//txs := make(chan []BitcoinTxNode, 1)
	//in := make(chan []BitcoinOutputEdge)
	//out := make(chan []BitcoinOutputEdge)
	//next := make(chan []BitcoinNextEdge)
	//parents := make(chan []BitcoinParentBlockEdge)
	
	var n uint64
	for n = start; n <= end ; n ++ {
		/* get blockhash */
		hash, err := bc.GetBlockHash(n)
		if err != nil {
			log.Fatalf("Failed to get blockHash: %v", err)
		}
		log.Printf("block %d has blockHash: %s\n", n, hash)
		/* get block */
		block, err := bc.GetBlock(hash)
		if err != nil {
			log.Fatalf("Failed to get blockBlock: %v", err)
		}
		str := strconv.FormatInt(int64(block.Height), 10)
		//log.Printf("fileds for btcBlock: height: %d, key: %s, hash: %s\n", block.Height, str, hash)
		arr_block = append(arr_block, BitcoinBlockNode{ BlockHeight: block.Height, Key: str, BlockHash: hash, })
		//blocks <- arr_block
		
		/* get all txid from msg_block */
		/* for each txid get the raw transaction */
		for _, t := range block.Tx {
			msg_tx, _ := bc.GetRawTransactionUPD(t, true)	// my method GetRawTransactionUPD I added to package
			if err != nil {
				log.Fatalf("Failed to get rawTransaction: %v", err)
			}		
			//log.Printf("fileds for btcTx: key: %s\ntime: %d\n", msg_tx.Txid, msg_tx.Time)
			arr_tx = append(arr_tx, BitcoinTxNode{ Key: msg_tx.Txid, Time: msg_tx.Time})
			//txs <- arr_tx
			
			
			parentBlockKey := str + "_" + msg_tx.Txid
			//log.Printf("_key in btcParentBlock: %s\n", parentBlockKey)
			arr_parent = append(arr_parent, BitcoinParentBlockEdge{ Key: parentBlockKey,
										  From: "btcTx/" + msg_tx.Txid,
										  To: "btcBlock/" + strconv.Itoa(int(n)), 
										})
			//parents <- arr_parent
			
			for _, vin := range msg_tx.Vin {
				txid := vin.Txid
				//log.Printf("txid field: %s", txid)
				vout := vin.Vout //int
				voutstr := strconv.Itoa(vout)
				//log.Printf("vout field: %s", voutstr)
				var edgesKey, edgeOutKey string
				if txid == "" && voutstr == "" {
					edgesKey = ""
					edgeOutKey = ""
				} else if txid == "" && voutstr != "" {
					edgesKey = ""
					edgeOutKey = msg_tx.Txid + "_" + voutstr
				} else {
					edgesKey = txid + "_" + voutstr
					edgeOutKey = msg_tx.Txid + "_" + voutstr
				}
				//log.Printf("_key in btcIn: %s\n", edgesKey)
				//log.Printf("_key in btcOut: %s\n", edgeOutKey)
				//log.Printf("_key in btcNext: %s\n", edgesKey)
				
				/* searching for fields spentBtc(val) and time*/
				var time int64
				var val float64
				if txid != ""{
					tx, err := bc.GetRawTransactionUPD(txid, true)	
					if err != nil {
						log.Printf("Failed to get rawTransaction here: %v", err)
						log.Println(len(txid))
						log.Println(tx)
					} 
				} 
				time = msg_tx.Time
				for _, v := range msg_tx.Vout {
					if v.N == vout {
						val = v.Value
					}
				} 
				
				if edgesKey != "" {
					arr_in = append(arr_in, BitcoinOutputEdge{ 
											Key: edgesKey,
											From: "btcAddress/t",	//?
											To: "btcTx/t",		//?
											OutIndex: vout,
											SpentBtc: uint64(val * math.Pow10(8)),
											Time: time, })
					//in <- arr_in
					
					arr_next = append(arr_next, BitcoinNextEdge{ 
											Key: edgesKey,
											From: "btcTx/t",	//?
											To: "btcTx/t",		//?
											Address: "",		//?
											OutIndex: vout,
											SpentBtc: uint64(val * math.Pow10(8)), })
					//next <- arr_next
					
				}
				if edgeOutKey != "" {
					arr_out = append(arr_out, BitcoinOutputEdge{ 
											Key: edgeOutKey,
											From: "btcTx/" + msg_tx.Txid,
											To: "btcAddress/t",	//?
											OutIndex: vout,
											SpentBtc: uint64(val * math.Pow10(8)),
											Time: time, })
					//out <- arr_out
										
				}
				
			}
		}
		CheckFieldsofTxNode(db, "btcTx", arr_tx, file)
		CheckFieldsofParentEdge(db, "btcParentBlock", arr_parent, file)
		CheckFieldsofInOutEdge(db, "btcOut", arr_in, file)
		CheckFieldsofNextEdge(db, "btcNext", arr_next, file)
		CheckFieldsofInOutEdge(db, "btcIn", arr_in, file)
		
	}
	CheckFieldsofBlockNode(db, "btcBlock", arr_block, file)
	log.Println("end of process")
}


/* ====================== helpful functions ====================== */
func CheckFieldsofInOutEdge(db driver.Database, coll string, arr []BitcoinOutputEdge, file *os.File) {
	//get docs from chan and open collection with "coll" name
	//arr := <-ch
	//log.Println("got nodes from channel " + "coll_name is " + coll)
	col, err := db.Collection(nil, coll)
	if err != nil {
		log.Fatalf("Failed openning the collection: %v", err)
	}
	var doc BitcoinOutputEdge 
	for _, a := range arr{
		_, err := col.ReadDocument(nil, a.Key, &doc)
		if err != nil {
    			log.Fatalf("Failed reading doc: %v", err)
		}
		fmt.Printf("doc: %#v\n", doc)	
		//fmt.Printf("doc.Key: %s\n", doc.Key)
		//fmt.Printf("doc.From: %s\n", doc.From)
		//fmt.Printf("doc.To: %s\n", doc.To)
		//fmt.Printf("doc.OutIndex: %d\n", doc.OutIndex)
		//fmt.Printf("doc.SpentBtc: %d\n", doc.SpentBtc)
		//fmt.Printf("doc.Time: %d\n", doc.Time)
		//fmt.Printf("\n a.Key: %s\n", a.Key)
		//fmt.Printf("a.From: %s\n", a.From)
		//fmt.Printf("a.To: %s\n", a.To)
		//fmt.Printf("a.OutIndex: %d\n", a.OutIndex)
		//fmt.Printf("a.SpentBtc: %d\n", a.SpentBtc)
		//fmt.Printf("a.Time: %d\n", a.Time)
		var f, t bool
		if coll == "btcIn" {
			f, t = strings.Contains(doc.From, "btcAddress"), strings.Contains(doc.To, "btcTx")
		}
		if coll == "btcOut" {
			f, t = strings.Contains(doc.From, "btcTx"), strings.Contains(doc.To, "btcAddress")
		}
		ind, spent, time := doc.OutIndex == a.OutIndex, doc.SpentBtc == a.SpentBtc, doc.Time == a.Time
		if !(f && t && ind && spent && time) {
			file.WriteString(coll + ",  _key: " + a.Key + "\n")
		}
	}
}

func CheckFieldsofNextEdge(db driver.Database, coll string, arr []BitcoinNextEdge, file *os.File) {
	//get docs from chan and open collection with "coll" name
	//arr := <-ch
	//log.Println("got nodes from channel " + "coll_name is " + coll)
	col, err := db.Collection(nil, coll)
	if err != nil {
		log.Fatalf("Failed openning the collection: %v", err)
	}
	var doc BitcoinNextEdge 
	for _, a := range arr{
		_, err := col.ReadDocument(nil, a.Key, &doc)
		if err != nil {
    			log.Fatalf("Failed reading doc: %v", err)
		}
		fmt.Printf("doc: %#v\n", doc)	
		//fmt.Printf("doc.Key: %s\n", doc.Key)
		//fmt.Printf("doc.From: %s\n", doc.From)
		//fmt.Printf("doc.To: %s\n", doc.To)
		//fmt.Printf("doc.Address: %s\n", doc.Address)
		//fmt.Printf("doc.OutIndex: %d\n", doc.OutIndex)
		//fmt.Printf("doc.SpentBtc: %d\n", doc.SpentBtc)
		//fmt.Printf("\n a.Key: %s\n", a.Key)
		//fmt.Printf("a.From: %s\n", a.From)
		//fmt.Printf("a.To: %s\n", a.To)
		//fmt.Printf("a.Address: %s\n", a.Address)
		//fmt.Printf("a.OutIndex: %d\n", a.OutIndex)
		//fmt.Printf("a.SpentBtc: %d\n", a.SpentBtc)
		f, t, ad := strings.Contains(doc.From, "btcTx"), strings.Contains(doc.To, "btcTx"), strings.Contains(doc.Address, "")
		ind, spent := doc.OutIndex == a.OutIndex, doc.SpentBtc == a.SpentBtc
		if !(f && t && ad && ind && spent) {
			file.WriteString(coll + ", _key: " + a.Key + "\n")
		}
	}
}

func CheckFieldsofParentEdge(db driver.Database, coll string, arr []BitcoinParentBlockEdge, file *os.File) {
	//get docs from chan and open collection with "coll" name
	//arr := <-ch
	//log.Println("got nodes from channel " + "coll_name is " + coll)
	col, err := db.Collection(nil, coll)
	if err != nil {
		log.Fatalf("Failed openning the collection: %v", err)
	}
	var doc BitcoinParentBlockEdge 
	for _, a := range arr{
		_, err := col.ReadDocument(nil, a.Key, &doc)
		if err != nil {
    			log.Fatalf("Failed reading doc: %v", err)
		}
		fmt.Printf("doc: %#v\n", doc)	
		//fmt.Printf("doc.Key: %s\n", doc.Key)
		//fmt.Printf("doc.From: %s\n", doc.From)
		//fmt.Printf("doc.To: %s\n", doc.To)
		f, t := doc.From == a.From, doc.To == a.To
		if !(f && t) {
			file.WriteString(coll + ", _key: " + a.Key + "\n")
		}
	}	
}

func CheckFieldsofTxNode(db driver.Database, coll string, arr []BitcoinTxNode, file *os.File) {
	//get docs from chan and open collection with "coll" name
	//arr := <-ch
	//log.Println("got nodes from channel, " + "coll_name is " + coll)
	col, err := db.Collection(nil, coll)
	if err != nil {
		log.Fatalf("Failed openning the collection: %v", err)
	}
	var doc BitcoinTxNode 
	for _, a := range arr{
		_, err := col.ReadDocument(nil, a.Key, &doc)
		if err != nil {
    			log.Fatalf("Failed reading doc: %v", err)
		}
		fmt.Printf("doc: %#v\n", doc)	
		//fmt.Printf("doc.Key: %s\n", doc.Key)
		//fmt.Printf("doc.Time: %d\n", doc.Time)
		t := doc.Time == a.Time
		if !t {
			file.WriteString(coll + ", _key: " + a.Key + "\n")
		}
	}
}

func CheckFieldsofBlockNode(db driver.Database, coll string, arr []BitcoinBlockNode, file *os.File) {
	//get docs from chan and open collection with "coll" name
	//arr := <-ch
	//log.Println("got nodes from channel, " + "coll_name is " + coll)
	col, err := db.Collection(nil, coll)
	if err != nil {
		log.Fatalf("Failed openning the collection: %v", err)
	}
	var doc BitcoinBlockNode //= &BitcoinBlockNode{}
	for _, a := range arr{
		_, err := col.ReadDocument(nil, a.Key, &doc)
		if err != nil {
    			log.Fatalf("Failed reading doc: %v", err)
		}
		fmt.Printf("doc: %#v\n", doc)	
		fmt.Printf("doc.Key: %s\n", doc.Key)
		fmt.Printf("doc.BlockHash: %s\n", doc.BlockHash)
		fmt.Printf("doc.BlockHeight: %d\n", doc.BlockHeight)
		hash, h := doc.BlockHash == a.BlockHash, doc.BlockHeight == a.BlockHeight
		if !(hash && h) {
			file.WriteString(coll + ", _key: " + a.Key + "\n")
		}
	}	
}

